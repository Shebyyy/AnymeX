name: Track and Categorize Commits

on:
  push:
    branches:
      - idk

jobs:
  sendMessage:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
      actions: read
    steps:
      - name: Clone repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download last SHA artifact
        uses: dawidd6/action-download-artifact@v6
        with:
          workflow: dart.yml
          name: last-sha
        continue-on-error: true

      - name: Get Commits Since Last Run
        id: get_commits
        run: |
          if [ -f last_sha.txt ]; then
            LAST_SHA=$(cat last_sha.txt)
            echo "‚úÖ Found last SHA: $LAST_SHA"
          else
            echo "‚ö†Ô∏è No previous SHA found, using first commit."
            LAST_SHA=$(git rev-list --max-parents=0 HEAD)
          fi
          echo "Fetching commits since $LAST_SHA..."
          COMMIT_LOGS=$(git log $LAST_SHA..HEAD --pretty=format:"‚óè %s ~%an [÷ç](https://github.com/${{ github.repository }}/commit/%H)")
          if [ -z "$COMMIT_LOGS" ]; then
            echo "‚ö†Ô∏è No new commits found."
            exit 0
          fi
          # URL-encode for GitHub Actions
          COMMIT_LOGS="${COMMIT_LOGS//'%'/'%25'}"
          COMMIT_LOGS="${COMMIT_LOGS//$'\n'/'%0A'}"
          COMMIT_LOGS="${COMMIT_LOGS//$'\r'/'%0D'}"
          echo "Commits retrieved: $COMMIT_LOGS"
          echo "COMMIT_LOG=$COMMIT_LOGS" >> $GITHUB_ENV
          echo "$COMMIT_LOGS" > commit_log.txt
          
          # Extract branch name
          BRANCH=${{ github.ref }}
          BRANCH=${BRANCH#refs/heads/}
          echo "BRANCH=${BRANCH}" >> $GITHUB_ENV

      - name: Set up commit categorization
        run: |
          # Create scripts directory and parser script
          mkdir -p scripts
          cat > scripts/tel_commit_parser.sed << 'EOF'
          #!/bin/sed -f
          s/%0A/\n/g
          s/%25/%/g
          s/%0D/\r/g
          EOF
          chmod +x scripts/tel_commit_parser.sed
          
          # Create header
          echo "<b>üì£ New commits in branch <code>${BRANCH}</code></b>" > header.txt
      
      - name: Categorize commits
        run: |
          # Decode commits
          echo "$COMMIT_LOG" | sed 's/%0A/\n/g' > all_commits.txt
          
          # Create empty files for each category
          echo "**üöÄ Features**" > TFeatures.txt
          echo "**üêõ Fixes**" > TFixes.txt
          echo "**üîß Refactors**" > TRefactors.txt
          echo "**üíÖ Style**" > TStyle.txt
          echo "**‚ö° Performance**" > TPerformance.txt
          echo "**üõ† Chores**" > TChores.txt
          
          touch feat.txt fixes.txt refactors.txt style.txt perf.txt chores.txt
          
          # Process each commit and categorize
          commit_count_feat=0
          commit_count_fix=0
          commit_count_refactor=0
          commit_count_style=0
          commit_count_perf=0
          commit_count_chore=0
          
          while IFS= read -r line; do
            # Extract commit hash (last 7 characters) from the link
            commit_hash=$(echo "$line" | grep -o "commit/[a-f0-9]*" | sed 's/commit\///' | cut -c1-7)
            commit_link=$(echo "$line" | grep -o "\[÷ç\](https://[^)]*)" | sed 's/\[÷ç\]//g')
            commit_msg=$(echo "$line" | sed -e 's/‚óè //' -e 's/ ~.*//')
            
            formatted_line="[${commit_hash}]${commit_link}: ${commit_msg}"
            
            if [[ "$line" == *"‚óè feat:"* ]] && [ $commit_count_feat -lt 5 ]; then
              echo "$formatted_line" >> feat.txt
              ((commit_count_feat++))
            elif [[ "$line" == *"‚óè fix:"* || "$line" == *"‚óè bug:"* || "$line" == *"‚óè improvement:"* || "$line" == *"‚óè patch:"* ]] && [ $commit_count_fix -lt 5 ]; then
              echo "$formatted_line" >> fixes.txt
              ((commit_count_fix++))
            elif [[ "$line" == *"‚óè refactor:"* ]] && [ $commit_count_refactor -lt 5 ]; then
              echo "$formatted_line" >> refactors.txt
              ((commit_count_refactor++))
            elif [[ "$line" == *"‚óè style:"* ]] && [ $commit_count_style -lt 5 ]; then
              echo "$formatted_line" >> style.txt
              ((commit_count_style++))
            elif [[ "$line" == *"‚óè perf:"* ]] && [ $commit_count_perf -lt 5 ]; then
              echo "$formatted_line" >> perf.txt
              ((commit_count_perf++))
            elif [[ "$line" == *"‚óè chore:"* || "$line" == *"‚óè docs:"* || "$line" == *"‚óè build:"* || "$line" == *"‚óè ci:"* ]] && [ $commit_count_chore -lt 5 ]; then
              echo "$formatted_line" >> chores.txt
              ((commit_count_chore++))
            fi
          done < all_commits.txt
      
      - name: Process and clean commit files
        run: |
          # Process each file through the parser
          chmod +x scripts/tel_commit_parser.sed
          
          ./scripts/tel_commit_parser.sed feat.txt > feat_clean.txt
          ./scripts/tel_commit_parser.sed fixes.txt > fixes_clean.txt
          ./scripts/tel_commit_parser.sed refactors.txt > refactors_clean.txt
          ./scripts/tel_commit_parser.sed style.txt > style_clean.txt
          ./scripts/tel_commit_parser.sed perf.txt > perf_clean.txt
          ./scripts/tel_commit_parser.sed chores.txt > chores_clean.txt
          
          ./scripts/tel_commit_parser.sed TFeatures.txt > TFeaturesT.txt
          ./scripts/tel_commit_parser.sed TFixes.txt > TFixesT.txt
          ./scripts/tel_commit_parser.sed TRefactors.txt > TRefactorsT.txt
          ./scripts/tel_commit_parser.sed TStyle.txt > TStyleT.txt
          ./scripts/tel_commit_parser.sed TPerformance.txt > TPerformanceT.txt
          ./scripts/tel_commit_parser.sed TChores.txt > TChoresT.txt
          
          # Check and remove empty categories
          if [ ! -s feat_clean.txt ] || [ "$(tr -d '[:space:]' < feat_clean.txt)" = "" ]; then
              rm -f feat_clean.txt TFeaturesT.txt
          fi
          if [ ! -s fixes_clean.txt ] || [ "$(tr -d '[:space:]' < fixes_clean.txt)" = "" ]; then
              rm -f fixes_clean.txt TFixesT.txt
          fi
          if [ ! -s refactors_clean.txt ] || [ "$(tr -d '[:space:]' < refactors_clean.txt)" = "" ]; then
              rm -f refactors_clean.txt TRefactorsT.txt
          fi
          if [ ! -s style_clean.txt ] || [ "$(tr -d '[:space:]' < style_clean.txt)" = "" ]; then
              rm -f style_clean.txt TStyleT.txt
          fi
          if [ ! -s perf_clean.txt ] || [ "$(tr -d '[:space:]' < perf_clean.txt)" = "" ]; then
              rm -f perf_clean.txt TPerformanceT.txt
          fi
          if [ ! -s chores_clean.txt ] || [ "$(tr -d '[:space:]' < chores_clean.txt)" = "" ]; then
              rm -f chores_clean.txt TChoresT.txt
          fi
      
      - name: Combine and send to Telegram
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          # Combine categories into final output
          {
              cat header.txt
              echo ""
              [ -f TFeaturesT.txt ] && [ -f feat_clean.txt ] && echo -n "$(cat TFeaturesT.txt) <blockquote>$(cat feat_clean.txt)</blockquote> "
              [ -f TFixesT.txt ] && [ -f fixes_clean.txt ] && echo -n "$(cat TFixesT.txt) <blockquote>$(cat fixes_clean.txt)</blockquote> "
              [ -f TRefactorsT.txt ] && [ -f refactors_clean.txt ] && echo -n "$(cat TRefactorsT.txt) <blockquote>$(cat refactors_clean.txt)</blockquote> "
              [ -f TStyleT.txt ] && [ -f style_clean.txt ] && echo -n "$(cat TStyleT.txt) <blockquote>$(cat style_clean.txt)</blockquote> "
              [ -f TPerformanceT.txt ] && [ -f perf_clean.txt ] && echo -n "$(cat TPerformanceT.txt) <blockquote>$(cat perf_clean.txt)</blockquote> "
              [ -f TChoresT.txt ] && [ -f chores_clean.txt ] && echo -n "$(cat TChoresT.txt) <blockquote>$(cat chores_clean.txt)</blockquote> "
              echo ""
              echo "‚ùì<a href='https://github.com/${{ github.repository }}/blob/main/INSTALLATION.md'>Don't know which version to download? Click here!</a>"
          } > output.txt
          
          if [ ! -s output.txt ]; then
              echo "No commits found. Skipping Telegram message."
              exit 0
          fi
          
          markdown_info_tel=$(< output.txt)
          echo "Final Telegram Message:"
          echo "$markdown_info_tel"
          
          curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage" \
              -d "chat_id=$TELEGRAM_CHAT_ID" \
              -d "text=$markdown_info_tel" \
              -d "parse_mode=HTML" \
              -d "disable_web_page_preview=true"
      
      - name: Save current SHA for next run
        run: |
          git rev-parse HEAD > last_sha.txt
          
      - name: Upload SHA as artifact
        uses: actions/upload-artifact@v3
        with:
          name: last-sha
          path: last_sha.txt
          retention-days: 90
